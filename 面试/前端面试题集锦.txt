==============================================================================================================================
seo优化
==============================================================================================================================
一、从HTML代码，网站方面讨论
1、合理的title、description、keywords
2、语言化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页（用最恰当的标签来标记内容）
3、非装饰性图片必须加alt
4、提高网站速度：网站速度是搜索引擎排序的一个重要指标

二、从搜索引擎，网络爬虫方面讨论
1、重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
2、重要内容不要用js输出：爬虫不会执行js获取内容
3、少用iframe：搜索引擎不会抓取iframe中的内容
==============================================================================================================================
HTTP的几种请求方法用途
==============================================================================================================================
1、GET方法
发送一个请求来取得服务器上的某一资源

2、POST方法
向指定的服务器提交数据或附加新的数据

3、PUT方法
跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有

4、HEAD方法
只请求页面的首部

5、DELETE方法
删除服务器上的某资源

6、OPTIONS方法
它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息

7、TRACE方法
TRACE方法被用于激发一个远程的，应用层的请求消息回路

8、CONNECT方法
把请求连接转换到透明的TCP/IP通道
==============================================================================================================================

==============================================================================================================================
ES6
==============================================================================================================================
es6异步/并发操作 https://www.cnblogs.com/jaxu/p/6592210.html
es6 this指向 https://www.jianshu.com/p/2a403f010657
ES6 改变this指向 call、apply、bind  https://blog.csdn.net/weixin_45959504/article/details/105904843



==============================================================================================================================
webpack
==============================================================================================================================
webpack 异步加载 
webpack使用require.ensure将vue页面打包成独立的chunk文件，也可以将多个vue页面合并成一个chunk文件，以实现生产环境按需加载。

==============================================================================================================================
vue
==============================================================================================================================
vue & axios https://www.jianshu.com/p/d771bbc61dab
vuex
vue.nextTick()方法的使用
子父组件通信
vue 实现防抖、节流
==============================================================================================================================
浏览器
==============================================================================================================================

前端浏览器的两种缓存:协商缓存和强缓存

前端继承方式汇总    
https://www.cnblogs.com/baixiaoxiao/p/11046666.html   
https://www.cnblogs.com/shamoyuu/p/4770235.html


==============================================================================================================================
状态管理
==============================================================================================================================
react有redux，vue有vuex，angular2 有ngrx(ngrx是Angular基于Rxjs的状态管理)


==============================================================================================================================
angular2中数据状态管理方案有哪些？

首先，是谁告诉你React，Vue用了状态管理，
Angular也一定得用的？React，Vue是典型的shadowDom的MVVM模式，Angular是多范式的。数据驱动才"状态管理"，
事件驱动流式编程是指定数据变化关系而不是具体的数据的！即便是采用MVVM的模式，
Angular也可以通过依赖注入(具体数据)或者面向对象的方式解耦。知道有人会说ngRx，说实话我在ngRx这个莫名其妙的库上浪费了不少时间，
这个库给自己加了那么多戏，只是为了一个Redux的编程习惯，真的让人哭笑不得，不火是有原因的，毕竟只是个吸引React平台程序员的筹码。
状态管理维持不变性只是给你类似函数式编程的体验，事件流是较为纯粹的函数响应式编程——压根思考方式上就没有数据。
这样的问题就相当于问：Haskell，Racket为什么不用状态管理？别人都没有全局变量，想状态管理都不行，这不出难题么？
就不能安安心心用state monad?你看，这个state monad很明显抄袭了Redux！
https://www.zhihu.com/question/46662780


==============================================================================================================================
图表&可视化
==============================================================================================================================
d3.js 可视化

百度 echarts
可视化本地使用（不联网）
echarts 插入离线地图

==============================================================================================================================
后端渲染 前端渲染(前端后端分离) SPA(单页面富应用)
==============================================================================================================================
后端渲染：早期的页面渲染技术,前端页面包含后端代码,利用ASP，JSP,PHP技术通过服务器动态的渲染HTML页面。
前端渲染：通过ajax技术请求数据，以实现前后端分离，利用js动态渲染HTML页面。
SPA-单页面应用：在前端后端分离的基础上，增加了路由功能，以实现不同资源块的按需加载（不会跳转URL），
                整个网站资源只包含在一个HTML页面中，点击相关功能时，只加载该功能关联的资源块，不用刷新整个页面。
                缺点：首次打开页面慢。
==============================================================================================================================
实现“无页面刷新”的两种方式--基于 hash&history.pushState 的前端路由实现
==============================================================================================================================
vue-router 默认 hash 模式

URL hash模式： location.hash=''

H5 history 模式：
history.pushState({},'','home')
history.replaceState({},'','home')
history.go(num);    --num:正负整数
history.back(num);  --num:正负整数
history.back()=history.go(-1)
history.forward=history.go(1)

*pushState 配合go或back使用时，返回或前进顺序类似栈的先进后出，后进先出模式
*replaceState 无前进或返回

==============================================================================================================================

==============================================================================================================================



